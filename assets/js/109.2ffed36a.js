(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{483:function(n,t,s){"use strict";s.r(t);var e=s(4),r=Object(e.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h1",{attrs:{id:"并发"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并发"}},[this._v("#")]),this._v(" 并发")]),this._v(" "),n("p",[this._v("12.1　什么是线程 552\n12.2　线程状态 555\n12.2.1　新建线程 556\n12.2.2　可运行线程 556\n12.2.3　阻塞和等待线程 556\n12.2.4　终止线程 558\n12.3　线程属性 558\n12.3.1　中断线程 558\n12.3.2　守护线程 561\n12.3.3　线程名 561\n12.3.4　未捕获异常的处理器 561\n12.3.5　线程优先级 563\n12.4　同步 563\n12.4.1　竞态条件的一个例子 563\n12.4.2　竞态条件详解 567\n12.4.3　锁对象 568\n12.4.4　条件对象 571\n12.4.5　synchronized关键字 576\n12.4.6　同步块 579\n12.4.7　监视器概念 580\n12.4.8　volatile字段 581\n12.4.9　final变量 582\n12.4.10　原子性 582\n12.4.11　死锁 584\n12.4.12　线程局部变量 586\n12.4.13　为什么废弃stop和suspend方法 587\n12.5　线程安全的集合 589\n12.5.1　阻塞队列 589\n12.5.2　高效的映射、集和队列 595\n12.5.3　映射条目的原子更新 596\n12.5.4　对并发散列映射的批操作 599\n12.5.5　并发集视图 600\n12.5.6　写数组的拷贝 601\n12.5.7　并行数组算法 601\n12.5.8　较早的线程安全集合 602\n12.6　任务和线程池 603\n12.6.1　Callable与Future 603\n12.6.2　执行器 605\n12.6.3　控制任务组 607\n12.6.4　fork-join框架 612\n12.7　异步计算 615\n12.7.1　可完成Future 615\n12.7.2　组合可完成Future 616\n12.7.3　用户界面回调中的长时间运行任务 622\n12.8　进程 628\n12.8.1　建立一个进程 628\n12.8.2　运行一个进程 630\n12.8.3　进程句柄 631")])])}),[],!1,null,null,null);t.default=r.exports}}]);