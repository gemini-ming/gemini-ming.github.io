(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{493:function(a,e,t){"use strict";t.r(e);var r=t(1),s=Object(r.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"分布式消息-事件-驱动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式消息-事件-驱动"}},[a._v("#")]),a._v(" 分布式消息（事件）驱动")]),a._v(" "),e("h2",{attrs:{id:"_1、简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、简介"}},[a._v("#")]),a._v(" 1、简介")]),a._v(" "),e("p",[a._v("事件驱动架构(Event-driven 架构，简称 EDA)是软件设计领域内的一套程序设计模型。")]),a._v(" "),e("p",[a._v("这套模型的意义是"),e("strong",[a._v("所有的操作通过事件的发送/接收来完成")]),a._v("。")]),a._v(" "),e("p",[e("em",[a._v("传统软件设计")])]),a._v(" "),e("p",[a._v("举个例子，比如一个订单的创建在传统软件设计中服务端"),e("strong",[a._v("通过接口")]),a._v("暴露创建订单的动作，然后客户端访问创建订单。")]),a._v(" "),e("p",[e("em",[a._v("事件驱动设计")])]),a._v(" "),e("p",[a._v("在事件驱动设计里，订单的创建"),e("strong",[a._v("通过接收")]),a._v("订单事件来完成，这个过程中有事件发送者和事件接受者这两个模块，事件发送者的作用是发送订单事件，事件接受者的作用的接收订单事件。")]),a._v(" "),e("h2",{attrs:{id:"_2、spring-消息编程模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、spring-消息编程模型"}},[a._v("#")]),a._v(" 2、Spring 消息编程模型")]),a._v(" "),e("p",[a._v("不同的消息中间件发送消息的代码：")]),a._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"image","data-src":"https://cmty256.github.io/imgs-blog/microservice/image.35qn4fogc280.webp",loading:"lazy"}})]),a._v(" "),e("p",[a._v("可以看出，每个消息中间件都有自己的消息模型编程。")]),a._v(" "),e("p",[e("em",[a._v("统一模型")])]),a._v(" "),e("p",[a._v("Spring 生态里有两个消息相关的模块和项目，分别是 spring-messaging 模块和 Spring Integration 项目，它们对消息的编程模型进行了统一，不论是 Apache RocketMQ 的 Message，或者是 Apache Kafka 的 ProducerRecord，都被统一称为 "),e("code",[a._v("org.springframework.messaging.Message")]),a._v(" 接口。")]),a._v(" "),e("p",[a._v("Message 接口有两个方法，分别是 "),e("code",[a._v("getPayload")]),a._v(" 以及 "),e("code",[a._v("getHeaders")]),a._v(" 用于获取消息体以及消息头。这也意味着"),e("strong",[a._v("一个消息 Message 由 Header 和 Payload 组成")]),a._v("。")]),a._v(" "),e("blockquote",[e("p",[a._v("Payload 是一个泛型，意味是消息体可以放任意数据类型。Header 是一个 MessageHeaders 类型的消息头。")])]),a._v(" "),e("p",[e("em",[a._v("有了消息之后，这个消息被发送到哪里呢？")])]),a._v(" "),e("p",[a._v("Spring 提供了消息通道 MessageChannel 的概念。消息可以被发送到消息通道里，然后再通过消息处理器 MessageHandler 去处理消息通道里的消息。")]),a._v(" "),e("p",[e("em",[a._v("如果消息通道里只有 1 个消息，但是消息处理器有 N 个，这个时候要被哪个消息处理器处理呢？")])]),a._v(" "),e("p",[a._v("这里又涉及一个"),e("strong",[a._v("消息分发器")]),a._v("的问题。")]),a._v(" "),e("ul",[e("li",[a._v("UnicastingDispatcher 表示单播的处理方式，消息会"),e("strong",[a._v("通过负载均衡")]),a._v("被分发到某一个消息处理器上（默认）")]),a._v(" "),e("li",[a._v("BroadcastingDispatcher 表示广播的方式，消息会被所有的消息处理器处理。")])]),a._v(" "),e("h2",{attrs:{id:"_3、spring-cloud-stream"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、spring-cloud-stream"}},[a._v("#")]),a._v(" 3、Spring Cloud Stream")]),a._v(" "),e("p",[a._v("Spring Cloud Stream 是一套基于消息的事件驱动开发框架，它提供了一套全新的消息编程模型，此模型"),e("strong",[a._v("屏蔽了底层具体消息中间件的使用方式")]),a._v("。开发者们使用这套模型可以完成基于消息的事件驱动应用开发。")]),a._v(" "),e("p",[a._v("Spring Cloud Stream 在上面说到的 spring-messaging 和 Spring Integration 项目的基础上再进行了一些封装，提出一些新的概念，让开发者能够更简单地使用这套消息编程模型。")]),a._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"image","data-src":"https://cmty256.github.io/imgs-blog/microservice/image.483w8e0uihg0.webp",loading:"lazy"}})]),a._v(" "),e("h2",{attrs:{id:"参考书籍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考书籍"}},[a._v("#")]),a._v(" 参考书籍")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://developer.aliyun.com/article/778252",target:"_blank",rel:"noopener noreferrer"}},[a._v("重磅下载 | Java 开发者必备手册《Spring Cloud Alibaba 从入门到实战》，阿里双11同款！-阿里云开发者社区 (aliyun.com)"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);