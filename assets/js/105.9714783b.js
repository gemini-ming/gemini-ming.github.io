(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{437:function(t,v,_){"use strict";_.r(v);var s=_(1),a=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"join-解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#join-解析"}},[t._v("#")]),t._v(" JOIN 解析")]),t._v(" "),v("h2",{attrs:{id:"五种-join-的含义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五种-join-的含义"}},[t._v("#")]),t._v(" 五种 JOIN 的含义")]),t._v(" "),v("ol",[v("li",[v("code",[t._v("INNER JOIN")]),t._v(": 内连接，返回两个表中都存在的匹配记录，即只返回满足连接条件的数据。")]),t._v(" "),v("li",[v("code",[t._v("LEFT JOIN")]),t._v("：左连接，返回左表中的所有记录，即使右表中没有匹配的记录。")]),t._v(" "),v("li",[v("code",[t._v("RIGHT JOIN")]),t._v("：右连接，返回右表中的所有记录，即使左表中没有匹配的记录。")]),t._v(" "),v("li",[v("code",[t._v("FULL JOIN")]),t._v("：全连接，返回左右两个表中的所有记录，无论是否有匹配的记录。")]),t._v(" "),v("li",[v("code",[t._v("comma-style JOIN")]),t._v("：也被称为交叉 JOIN 或"),v("strong",[t._v("逗号 JOIN")]),t._v("，只返回满足连接条件的数据。")])]),t._v(" "),v("h2",{attrs:{id:"逗号-join-的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#逗号-join-的问题"}},[t._v("#")]),t._v(" 逗号 JOIN 的问题")]),t._v(" "),v("p",[t._v("这是 SQL 中一种早期的 JOIN 语法形式。在 FROM 子句中，通过在两个或多个表名之间使用逗号来表示 JOIN 操作。")]),t._v(" "),v("p",[t._v("例如：")]),t._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" table1"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" table2"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" table3\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("p",[t._v("这种语法形式实际上执行的是一个 Cartesian product（笛卡尔积）操作，即"),v("strong",[t._v("所有表中的行两两组合。然后，WHERE 子句用于筛选出满足特定条件的组合。")])]),t._v(" "),v("p",[t._v("显然，这种语法形式有以下几个问题：")]),t._v(" "),v("ol",[v("li",[t._v("可读性较差：相比于现代的 INNER JOIN、LEFT JOIN、RIGHT JOIN 和 FULL JOIN 等语法，comma-style JOIN 的语义不那么直观。")]),t._v(" "),v("li",[t._v("性能问题：由于它首先生成了所有可能的行组合，然后再进行筛选，因此在处理大型数据集时可能会非常慢。")]),t._v(" "),v("li",[t._v("筛选条件限制：所有的连接条件必须在 WHERE 子句中指定，这可能会导致一些优化器无法充分利用索引。")])]),t._v(" "),v("p",[t._v("所以，笔者推荐使用明确的 JOIN 语句（如 "),v("code",[t._v("INNER JOIN")]),t._v("、"),v("code",[t._v("LEFT JOIN")]),t._v(" 等）来代替 "),v("code",[t._v("comma-style JOIN")]),t._v("，因为它们更清晰、可读性和性能通常更好，并且允许在 ON 子句中指定连接条件，这还可能有利于查询优化。")]),t._v(" "),v("h2",{attrs:{id:"单独一个-join-是怎么样的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单独一个-join-是怎么样的"}},[t._v("#")]),t._v(" 单独一个 JOIN 是怎么样的？")]),t._v(" "),v("p",[t._v("单独的 JOIN 语句没有指定具体的连接类型，因此"),v("strong",[t._v("默认情况下会执行 INNER JOIN")]),t._v("。如果需要执行其他类型的连接，需要在 JOIN 语句中指定相应的关键字。")]),t._v(" "),v("h2",{attrs:{id:"join-的底层原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#join-的底层原理"}},[t._v("#")]),t._v(" JOIN 的底层原理⭐️")]),t._v(" "),v("p",[t._v("JOIN 操作的底层原理涉及到【"),v("strong",[t._v("连接算法")]),t._v("】，其中包括以下几种常见的连接方法：")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("嵌套循环连接（Nested Loop Join）：")]),t._v(" "),v("ul",[v("li",[t._v("这是最简单的连接算法。对于每一行左表的记录，都在右表中进行一次循环，找到匹配的记录。这个方法适用于其中一个表很小，另一个表很大的情况。")])])]),t._v(" "),v("li",[v("strong",[t._v("哈希连接（Hash Join）：")]),t._v(" "),v("ul",[v("li",[t._v("对于大表和小表之间的连接，可以对小表进行哈希运算，然后使用哈希表来加速查找匹配的行。")])])]),t._v(" "),v("li",[v("strong",[t._v("排序合并连接（Merge Join）：")]),t._v(" "),v("ul",[v("li",[t._v("当连接的两个表都已经按连接条件排序时，可以通过同时扫描两个表，并逐行匹配连接条件来完成连接操作。")])])]),t._v(" "),v("li",[v("strong",[t._v("索引连接（Index Join）：")]),t._v(" "),v("ul",[v("li",[t._v("如果连接的条件涉及到了索引，数据库引擎可以使用索引来加速连接操作。")])])]),t._v(" "),v("li",[v("strong",[t._v("自连接（Self Join）：")]),t._v(" "),v("ul",[v("li",[t._v("自连接是指表与自身进行连接。在这种情况下，可能使用上述任何一种连接方法。")])])])]),t._v(" "),v("p",[t._v("实际使用的连接方法取决于数据库引擎的优化器，它会根据统计信息、表的大小、索引的情况等因素选择最优的连接方式。")]),t._v(" "),v("p",[t._v("在理解 JOIN 的底层原理时，重要的是要明白连接算法、连接顺序和连接类型的影响，以便优化查询性能。")])])}),[],!1,null,null,null);v.default=a.exports}}]);