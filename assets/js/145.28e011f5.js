(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{521:function(t,s,a){"use strict";a.r(s);var n=a(4),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"解题方法描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解题方法描述"}},[t._v("#")]),t._v(" 解题方法描述")]),t._v(" "),s("h2",{attrs:{id:"什么是动态规划"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是动态规划"}},[t._v("#")]),t._v(" 什么是动态规划？")]),t._v(" "),s("p",[t._v("动态规划（Dynamic Programming，简称DP）是一种在数学、管理科学、计算机科学、经济学动态规划（Dynamic Programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。")]),t._v(" "),s("p",[t._v("动态规划体现的主要环节是 【"),s("strong",[t._v("递归+记忆化")]),t._v("】，即反复调用自身(俗称套娃)并利用数据结构来存储已解决的子问题的答案，以便在后续需要时可以快速查找，而无需重复计算。")]),t._v(" "),s("p",[t._v("例如，斐波那契数列是一个经典的用例，我们可以通过动态规划的方式来求解每一项的值：定义这样一个数列，前两项值等于序列号，后面每一项是前两项之和，这样就可以通过反复调用自身来求解每一项的值。")]),t._v(" "),s("p",[t._v("此外，动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。")]),t._v(" "),s("h2",{attrs:{id:"什么时候用回溯法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么时候用回溯法"}},[t._v("#")]),t._v(" 什么时候用回溯法？")]),t._v(" "),s("p",[t._v("回溯法通常用于解决组合、排列、搜索等问题，其特点是在解决问题的过程中，需要多次尝试不同的选择，直到找到符合条件的解，或者所有的选择都尝试完毕后确定无解。具体来说，当问题满足以下条件时，可以考虑使用回溯法：")]),t._v(" "),s("ol",[s("li",[t._v("问题需要求出所有可能的解。")]),t._v(" "),s("li",[t._v("解空间非常大，但是可以通过剪枝等方式大大减少搜索空间。")]),t._v(" "),s("li",[t._v("问题可以表示成树形结构，每个节点表示一种选择，可以通过深度优先搜索实现回溯。")]),t._v(" "),s("li",[t._v("问题的每个解都可以用一个序列表示，序列中的元素表示选择的顺序。")]),t._v(" "),s("li",[t._v("问题具有单调性，即问题的最优解可以通过一定规则的选择得到。")])]),t._v(" "),s("p",[t._v("例如，求解 N 皇后问题、0-1 背包问题、全排列问题等就可以考虑使用回溯法。回溯法在实现上通常需要使用递归，因此需要注意递归的开销，以及如何剪枝，减少无用的搜索。")]),t._v(" "),s("h2",{attrs:{id:"分治法解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分治法解析"}},[t._v("#")]),t._v(" 分治法解析")]),t._v(" "),s("p",[t._v("分治法的基本思想是：将问题分解成更小的子问题，解决子问题后再合并得到原问题的解。")]),t._v(" "),s("p",[t._v("对于最大子数组问题，可以采用如下的分治策略：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("分解（Divide）：")]),t._v(" 将数组分成两半，分别求解左半部分和右半部分的最大子数组和。")]),t._v(" "),s("li",[s("strong",[t._v("合并（Combine）：")]),t._v(" 考虑最大子数组和跨越左右两半的情况。即求解包含中间元素的最大子数组和。")]),t._v(" "),s("li",[s("strong",[t._v("返回（Return）：")]),t._v(" 返回左半部分、右半部分和跨越中间的最大子数组和中的最大值。")])]),t._v(" "),s("h2",{attrs:{id:"贪心算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法"}},[t._v("#")]),t._v(" 贪心算法")]),t._v(" "),s("p",[t._v("贪心算法，也叫贪婪算法，是一种在求解问题时，总是做出当前看来是最好的选择的算法。")]),t._v(" "),s("p",[t._v("也就是说，它不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。具体来说，贪心算法的基本思路是："),s("strong",[t._v("通过每一步都选取局部最有利的选择，从而希望导致结果是全局最优的")]),t._v("。")]),t._v(" "),s("p",[t._v("贪心算法适用于一些特定问题，可以快速得到解决方案，但需要注意的是，由贪心算法得到的解决方案并不一定是全局最优解。这是因为贪心算法在每一步都选择局部最优解，而没有考虑到这些局部最优解组合起来的整体效果。因此，贪心算法更适用于一些局部最优解能够导致全局最优解的问题。")]),t._v(" "),s("p",[t._v("贪心算法的应用范围非常广泛，比如零钱找回问题、E点加入S问题和MST问题等。对于这些问题，贪心算法往往能够得到迅速且精确的解决方案。")]),t._v(" "),s("h2",{attrs:{id:"归并排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#归并排序"}},[t._v("#")]),t._v(" 归并排序")]),t._v(" "),s("p",[t._v("归并排序是一种基于"),s("strong",[t._v("分治思想")]),t._v("的排序算法，它将待排序的序列分成两个子序列，分别进行递归排序，然后将已排序的子序列合并成一个有序的序列。归并排序有两种主要的实现方式：自顶向下和自底向上。")]),t._v(" "),s("p",[s("strong",[t._v("自顶向下的归并排序")]),t._v("和"),s("strong",[t._v("自底向上的归并排序")]),t._v("都是应用了分治策略的一种有效的排序方式，不过他们在进行排序时的顺序有所不同。")]),t._v(" "),s("h3",{attrs:{id:"自顶向下的归并排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自顶向下的归并排序"}},[t._v("#")]),t._v(" 自顶向下的归并排序")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("分解：")]),t._v(" 将待排序序列递归地分解成两个子序列，直到每个子序列只有一个元素为止。")]),t._v(" "),s("li",[s("strong",[t._v("合并：")]),t._v(" 将已经排好序的子序列合并，不断地合并直到整个序列有序。")]),t._v(" "),s("li",[s("strong",[t._v("递归：")]),t._v(" 通过递归实现上述分解和合并的过程。")])]),t._v(" "),s("p",[t._v("自顶向下的归并排序是一种典型的递归算法。具体步骤如下：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mergeSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" low"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" high"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("low "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" high"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 分解：找到中间位置将序列分成两部分")]),t._v("\n        mid "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("low "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" high"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 递归地对左右两部分进行排序")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mergeSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" low"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mergeSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mid "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" high"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 合并：将两个已排序的子序列合并成一个有序序列")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("merge")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" low"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" high"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("h3",{attrs:{id:"自底向上的归并排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自底向上的归并排序"}},[t._v("#")]),t._v(" 自底向上的归并排序")]),t._v(" "),s("p",[t._v("自底向上的归并排序采用迭代的方式实现，不需要递归。")]),t._v(" "),s("p",[t._v("具体步骤如下：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("分组：")]),t._v(" 将原始序列看成是 n 个长度为 1 的子序列。")]),t._v(" "),s("li",[s("strong",[t._v("两两合并：")]),t._v(" 依次将相邻的两个子序列合并成一个更大的有序序列。")]),t._v(" "),s("li",[s("strong",[t._v("不断迭代：")]),t._v(" 重复合并直到整个序列有序。")])]),t._v(" "),s("p",[t._v("自底向上的归并排序可以看作是一种"),s("strong",[t._v("迭代")]),t._v("的归并过程。实现伪代码如下：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mergeSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子序列大小从1开始，逐渐加倍")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 合并相邻的两个子序列")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" mid "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Math")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("min")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Math")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("min")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 合并两个子序列")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("merge")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br")])]),s("h2",{attrs:{id:"bfs-和-dfs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bfs-和-dfs"}},[t._v("#")]),t._v(" BFS 和 DFS")]),t._v(" "),s("h3",{attrs:{id:"breadth-first-search"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#breadth-first-search"}},[t._v("#")]),t._v(" Breadth First Search")]),t._v(" "),s("p",[s("strong",[t._v("BFS（广度优先搜索）"),s("strong",[t._v("的思想是：对")]),t._v("每一层的节点")]),t._v("进行操作，再去下一层。假设利用一个队列实现 "),s("code",[t._v("BFS")]),t._v(" 翻转链表。")]),t._v(" "),s("ul",[s("li",[t._v("在队列中，新元素（在这里是指子树的根节点）总是被添加到队列的末尾，我们总是从队列的头部移除元素。")]),t._v(" "),s("li",[t._v("从队列的头部取出一个节点，如果这个节点有左子树或者右子树，就将其左子树和右子树翻转，然后将其左子树和右子树（如果存在的话）分别添加到队列的尾部。")])]),t._v(" "),s("h3",{attrs:{id:"depth-first-search"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#depth-first-search"}},[t._v("#")]),t._v(" Depth First Search")]),t._v(" "),s("p",[s("strong",[t._v("DFS（深度优先搜索）"),s("strong",[t._v("的思想是：对")]),t._v("某个节点")]),t._v("先深度遍历，直到找到最深的节点后，再回溯到下一个节点。假设利用一个栈实现 "),s("code",[t._v("DFS")]),t._v(" 翻转链表。")]),t._v(" "),s("ul",[s("li",[t._v("在栈中，新元素（在这里是指子树的根节点）总是被添加到栈的顶部，我们总是从栈的顶部移除元素。")]),t._v(" "),s("li",[t._v("从栈的顶部取出一个节点，然后将其左子树和右子树翻转，然后将其左子树和右子树（如果存在的话）分别添加到栈的顶部。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);